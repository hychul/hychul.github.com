---
title: 게임 리소스 로딩
date: 2018-04-04
categories:
- Game
tags:
- Development
- Game
- C#
---

 많은 수의 리소스가 존재하는 게임에서 한번에 메모리에 로드가 된다면 더이상 할당할 메모리 공간이 부족한 상황이 발생할 수 있기 때문에 리소스들은 메모리에 실시간으로 로드되고 해제된다. 프로젝트나 엔진 에디터에 존재하는 리소스들은 엔진이 관리해 줄 수 있지만, 런타임에 실시간으로 로드되고 해제되는 리소스들을 각 클래스에서 개별적으로 로드하고 있는 상황에선 관리되기 힘들다.

 각각의 클래스에서 직접 엔진의 리소스 로드 기능을 통해 리소스를 참조하는 것이 문제이기 때문에, 리소스 로드를 제3의 오브젝트에게 맡긴다면 리소스 로드에 대한 제어권을 클래스에서 어느정도 위임받을 수 있다. 

## 리소스 인젝션

 각 게임 오브젝트의 리소스 로드에 대한 모든 권한을 다른 오브젝트에 위임하는 방식이다. 

[다이어그램]

 게임 오브젝트에서 사용되는 리소스들은 게임 오브젝트와 함께 로드되기 때문에 게임 오브젝트를 로드하는 오브젝트에게 보통 리소스 로드의 권한을 주면 된다. 게임 오브젝트가 다양한 모양으로 존재하고 이 때문에 여러 리소스를 필요로 할 수 있기 때문에 리소스를 인젝션 받는 게임 오브젝트 메소드의 모양에 주의해야한다.

## 리소스 로더 랩핑

 엔진에서 제공하는 리소스를 로드하는 기능을 감싸는 오브젝트를 만들어 게임 오브젝트에게 제공한다면, 리소스가 로드될 때 프로그래머가 로드 과정에 관여를 할 수 있다.

 일반적인 게임의 옵션을 떠올려보자. 보통 크게 그래픽 옵션과 사운드 옵션이 존재하고, 그래픽 옵션에는 그래픽 품질을 설정하는 옵션들이, 사운드 옵션에서는 볼륨이나 음소거를 설정하는 옵션들이 존재한다. 그래픽과 사운드 모두 리소스에 대한 관리가 필요하지만 그래픽은 리소스 로드시에 



엔진의 리소스 로더를 직접 각 오브젝트에서 참조하여 사용하는 상황에서 이러한 옵션의 변화에 어떻게 대응할 수 있을까? 바로 프로그램에 맞게 엔진에서 가장 기본적인 기능을 감싸는 방식으로 개발하면 된다.

[다이어 그램]

```c#
public static class CustomResourceLoader
{
    public static T Load<T>(string path) where T : UnityEngine.Object
    {
        return Resources.Load<T>(path);
    }
}
```





-결론

 리소스의 변경은 혼자서 게임을 개발하는 경우에는 큰 문제가 되지 않을 수 있다. 하지만 다른 아티스트와 협업을 해야하는 경우엔 문제가 된다. 새로운 리소스가 추가되고 변경되었을 때, 이를 확인하는 작업을 위해 프로그래머가 관련 메소드를 추가하는 등의 작업을 수행해야하기 때문이다. 비슷한 구조를 갖는 게임 오브젝트인데 디렉토리 위치가 달라 다른 메소드를 사용하는 경우에도 비슷한 메소드를 여러번 구현해야 될 수 있다.

 많은 수의 리소스가 존재하는 게임에서 한번에 메모리에 로드가 된다면 더이상 할당할 메모리 공간이 부족한 상황이 발생할 수 있기 때문에 리소스들은 메모리에 실시간으로 로드되고 해제된다. 프로젝트나 엔진 에디터에 존재하는 리소스들은 엔진이 관리해 줄 수 있지만, 런타임 중에 실시간으로 로드되고 해제되는 리소스들은 각 클래스에서 개별적으로 참조하고 있는 상황에선 관리되기 힘들다.