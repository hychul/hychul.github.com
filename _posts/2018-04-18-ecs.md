---
title: ECS Model
date: 2018-04-18
categories:
- Game
tags:
- Development
- Game
---

 ECS는 Entity, Component, System의 약자로, 이 세가지의 요소로 설계하는 아키텍쳐 패턴이다. 몇몇 상용 엔진에서 잘 사용하고 있는 컴포넌트 모델<sup>Component Model</sup>과도 다르고, 90년대 후반과 2000년대 초반에 주로 쓰였던 고전적인 액터 모델<sup>Actor Model</sup>과도 확연히 다르다.

## 액터 모델

 액터모델은 '모든 것은 객체다'라는 OOP의 기본 개념과 비슷하게 '모든 것은 액터다'라는 기본 개념을 토대로 만들어진 모델이다. 액터 모델이 등장한 배경엔 멀티쓰레드가 있다. 

 힙<sup>Heap</sup>이 여러 개의 쓰레드에게 공유되고 Java와 C#에서 객체라는 메모리 공간이 기본적으로 변경가능<sup>Mutable</sup>한 이상 완벽하게 안전한 멀티쓰레드 코드를 작성하는 것은 가능하지 않다. 변경가능성<sup>Mutability</sup>과 자원의 공유<sup>Sharing</sup>는 죽음의 칵테일이다.

 액터는 쓰레드 혹은 객체와 구별되는 추상적인 개념이다. 액터가 차지하는 메모리 공간은 어느 다른 쓰레드 혹은 액터가 접근할 수 없다. 다시 말해서 액터 내부에서 일어나는 일은 어느 누구와도 공유되지 않는다. 앞서 언급한 죽음의 칵테일에서 공유라는 속성을 제거함으로써 멀티쓰레드와 관련된 문제의 대부분을 제거했다.

 각 액터들은 서로의 주소<sup>Mail Address</sup>를 통해 서로 메세지를 주고 받는 것으로 주어진 일을 동시에 수행한다. 단지 메시지만을 주고 받고 상태를 공유하지 않기 때문에 액터 내부에서 작업을 수행할 때는 lock이나 synchronized와 같은 부자연스러운 키워드가 필요 없다. 그래서 액터 모델에서는 잠금장치나 쓰레드라는 개념이 눈에 보이지 않는 어디론가 사라진다.

![ecs-1](https://user-images.githubusercontent.com/18159012/39060753-330d52f0-44fd-11e8-9545-f9de67a47a4b.png)

 ''메세지를 받으면 그에 맞는 로직을 실행한다''는 매우 간단한 동작원리와 다른 것에 영향을 받지 않는다는 특징 때문에 실행 순서를 이해하고 결과를 예측하기 매우 쉽다. 또한, 모든 간섭을 메세지를 통해서 한다는 것도 큰 장점이다. 하지만 반응성이 떨어지는 문제과 더불어, 비슷한 기능들을 제공하는 액터를 설계할 때 문제가 발생한다.

 예를 들어 다음과 같은 액터를 구현한다고 해보자.

|          |  조작  |  타기  |  공격  |  날기  |
| :------: | :----: | :----: | :----: | :----: |
| 플레이어 |  가능  | 불가능 |  가능  | 불가능 |
|    말    | 불가능 |  가능  | 불가능 | 불가능 |
|  고블린  | 불가능 | 불가능 |  가능  | 불가능 |
|  드래곤  | 불가능 |  가능  |  가능  |  가능  |

 어떤 식으로 구현을 해야할까? 모든 기능별로 메소드를 만들고 상속을 한다면 중복되는 구현이 너무 많다. 기능이 확장되는 방향으로 상속을 한다면 드래곤이 말을 상속 받고 플레이어가 고블린을 상속해야한다. 뭔가 이상하다.

## 컴포넌트 모델

 컴포넌트 모델은 이런 상황을 해결해 줄 수 있다. 컴포넌트 모델에서의 컴포넌트는 액터를 더 잘게 나눈 작은 기능의 단위이다. 액터처럼 상태과 로직을 담고 있지만 각 컴포넌트는 안 오브젝트를 구성하는 요소일 뿐이다. 기존 오브젝트를 액터로 대체하는 것과 차이가 있다.

![ecs-2](https://user-images.githubusercontent.com/18159012/39060767-3f0d64a0-44fd-11e8-9d11-837b748ca1d7.png)

 각 기능을 컴포넌트로 구현하고 각 행동에 필요한 컴포넌트만 추가해준다면 필요한 기능들을 수행하도록 할 수 있다. 또한 컴포넌트를 추가하는 게 아니라면 기존 컴포넌트들의 조합을 통해 새로운 오브젝트 또한 만들 수 있다. 구현의 중복을 피하고 코드의 재사용을 극대화 할 수 있다.

 하지만 기능을 아무리 작은 단위로 쪼갠다고 하더라도, 하나의 기능이 수행될 때 두 개 이상의 컴포넌트가 필요한 경우 각 컴포넌트간의 간섭이 생길 수 있다. 액터 모델에선 하나로 묶어서 관리되던 상태 정보들이 컴포넌트라는 작은 단위로 나눠져 관리되기 때문이다.

 문제는 하나의 컴포넌트에 존재하는 로직이 여러 컴포넌트의 상태 정보를 변경하는데서 발생한다. 컴포넌트 마다 상태정보 뿐만 아니라 로직이 존재하기 때문에 결국엔 로직끼리 영향을 주게 된다.

# ECS <sup>Entity Component System</sup>

 컴포넌트 모델이나 액터 모델의 경우 상태<sup>State</sup>와 로직<sup>Behavior</sup>을 동시에 갖고 있지만 ECS는 상태와 로직를 컴포넌트와 시스템, 이 두개의 요소를 통해 분리한다. 컴포넌트는 상태를 저장하고 로직이 없는 반면, 시스템은 로직은 있지만, 상태를 저장하지 않는다. 쉽게말해 컴포넌트는 Function이 없고, 시스템은 Field가 없다.

 컴포넌트는 로직을 담고 있지않기 때문에 한 로직이 여러개의 컴포넌트의 상태 정보에 접근하더라도 시스템끼리 서로를 호출하지 않는 한 로직끼리는 영향을 받지 않는다. 때문에 로직과 데이터를 확실히 분리함으로써, ECS는 빠르게 변화하는 코드베이스<sup>Code Base</sup>에서 복잡성<sup>Complexity</sup>을 효과적으로 관리할 수 있다.

 ECS는 다음과 같이 구성된다

![ecs-0](https://user-images.githubusercontent.com/18159012/38994825-6b792514-4422-11e8-9002-704e68d5ecf1.png)

 월드는 시스템과 엔티티의 집합체로 구성된다. 엔티티는 컴포넌트의 집합체에 해당하며 유니크한 아이디를 갖는다.  컴포넌트나 엔티티의 경우 로직이 없기 때문에, 게임의 모든 로직은 시스템을 통해서 수행된다. 게임의 한 프레임 또는 타임 틱<sup>Time Tick</sup> 마다 월드에 존재하는 시스템을 순회<sup>Iterate</sup>하며 로직을 실행한다. 여기서 시스템은 각 엔티티가 무엇인지 알 수 없다. 단지 로직이 수행되는데 필요로 하는 일부 컴포넌트에 관여하고, 그 일부 컴포넌트에 대해 같은 로직을 수행한다.

 시스템의 로직을 수행하는데 하나 이상의 컴포넌트를 필요할 경우 컴포넌트는 한 엔티티에 같이 포함되는 컴포넌트에 접근할 수 있어야한다. 로직은 엔티티가 무엇인지 모르지만 컴포넌트가 저장하는 정보는 한 엔티티에 대한 정보이기 때문이다. 컴포넌트가 담고 있는 데이터는 결국 엔티티를 나타내는 정보가 된다.

 ECS가 아닌 설계 모델에서 로직을 구현한다면 각 대상이 되는 엔티티의 입장에서 로직을 구현해야한다. 대상이 필요로하는 기능을 구현하게 되는데, 주의하지 않으면 중복된 로직을 구현하게 된다. 하지만 로직을 수행하는 시스템이 따로 존재하는 ECS의 경우엔 대상보다 기능, 로직에 집중하기 때문에 이러한 문제에서 좀 더 자유로울 수 있다.

 