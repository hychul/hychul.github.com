---
title: Reactor
date: 2019-01-10
categories:
- Development
tags:
- Development
- Java
- Reactor
---



# 리액티브 스트림이란

리액티브 스트림은 그 이름에서 알 수 있듯이 비동기 처리를 위한 스트림을 의미한다. 리액티브 스트림은 이벤트들이 비동기적으로 생산<sup>Produce</sup>되고 소비<sup>Comsume</sup>되도록 한다.

비동기 이벤트 처리에서 중요한 요소 중 하나는 백프레셔<sup>Back Presure</sup>를 해결하는 것이다. 만약 생산자가 이벤트를 생성하는 속도가 소비자가 이를 처리하는 속도보다 빠르다면, 처리 되지 못한 이벤트는 리소스 부족으로 인해 제대로 처리되지 못하게 된다. 리액티브 스트림에선 이를 방지하기 위해 소비자가 생산자에게 보낼 데이터의 양을 알릴 수 있도록 한다.

## Java 8 Strream과 차이

The core difference is that Reactive is a push model, whereas the Java 8 *Streams* are a pull model. **In reactive approach. events are pushed to the subscribers as they come in.**

The next thing to notice is a *Streams* terminal operator is just that, terminal, pulling all the data and returning a result. With Reactive we could have an infinite stream coming in from an external resource, with multiple subscribers attached and removed on an ad hoc basis. We can also do things like combine streams, throttle streams and apply backpressure, which we will cover next.

리액티브 스트림과 Stream의 가장 큰 차이는, 리액티브는 푸시 모델<sup>Push Model</sup>을 사용하고 Stream은 풀 모델을 사용한다는 것이다. 리액티브의 관점에서 이벤트들은 구독자가 들어왔을 때 구독자에게 푸시된다.



## 리액티브 스트림 이벤트

스트림은 시간이 지남에 따라 발생하는 일련의 데이터/이벤트/신호이다. 리액티브 스트림에선 다음 세가지 이벤트를 발생시킬 수 있다.

- onNext
- onComplete
- onError

스트림은 0개 이상의 onNext 이벤트를 발생시킨다. onNext 이벤트는 데이터를 포함한다. onComplete와 onError는 베타적으로 발생하며, 두 신호 모두 발생하지 않을 수도 있다.

리액티브 스트림은 Publisher를 통해 스트림을 정의하고 Publisher 가 발생시킨 이벤트를 Subscriber를 통해 처리한다.

## Publisher와 Subscriber

 리액티브 스트림은 Publisher에 의해 이벤트가 발생하지만, Subscriber가 구독하기 전까진 아무런 동작을 하지 않는다. 더 정확하게 말하면 Subscriber가 이벤트를 요청하기 전까진 이벤트를 발생시키지 않는다.

```java
public interface Publisher<T> {
    void subscribe(Subscriber<? super T> var1);
}
```

```java
public interface Subscriber<T> {
    void onSubscribe(Subscription var1);

    void onNext(T var1);

    void onError(Throwable var1);

    void onComplete();
}
```

 위의 코드는 리액터 스트림에서 정의하고 있는 Publisher와 Subscriber 인터페이스이다. 앞서 설명한 이벤트인 onNext, onError 그리고 onComplete가 Subscriber에 콜백 메서드처럼 정의되어있는 것을 알 수 있다. 하지만 설명하지 않는 부분이 하나 있는데  바로 `onSubscribe()` 메서드와 그의 파라메터인 `Subscription`이다.

 Subscriber는 `onSubscribe()` 메서드의 파라메터로 얻은 `Subscription`을 통해 Publisher에게 이벤트를 요청한다. Subscriber가 어떻게 이벤트를 요청하고 처리하는지 코드로 알아보자.

```java
Flux.range(1, 3).subscribe(new Subscriber<>() {
	@Override
    public void onSubscribe(Subscription subscription) {
		System.out.println("[Subscriber] onSubscribe");
	}

    @Override
    public void onNext(Integer item) {
    	System.out.println("[Subscriber] onNext : " + item);
	}

    @Override
    public void onError(Throwable throwable) {
    	System.out.println("[Subscriber] onError : " + throwable.getMessage());
	}

    @Override
    public void onComplete() {
    	System.out.println("[Subscriber] onComplete");
	}
});
```

 위의 코드는 각 이벤트 콜백 메서드에서 어떤 이벤트가 발생했는지 콘솔에 아웃풋을 남기도록 작성되었다. 하지만 직접 실행해보면 의도한 대로 동작하지 않고 `[Subscriber] onSubscribe` 로그만 남을 뿐이다. 그 이유는 이벤트를 요청하는 부분이 없기 때문이다.

 `Subscription` 에는 이벤트를 요청하기 위한 `request(long size)` 와 이벤트를 중지하기 위한 `cancel()` 메서드가 정의되어있다. 메서드 정의에서 알 수 있듯이 이벤트를 요청할 때 요청할 이벤트의 갯수를 지정할 수 있다. 

### 이벤트 수보다 많은 Subscription 요청

Publisher가 갖고있는 이벤트 (데이터)를 모두 onNext 이벤트를 통해서 처리하기 위해선 그 수와 같거나 더 많은 이벤트를 요청해야한다.

```java
    ...
	@Override
    public void onSubscribe(Subscription subscription) {
        System.out.println("[Subscriber] onSubscribe");
        subscription.request(3); // 이벤트 요청
    }
	...
```

위와 같이 Publisher의 이벤트 갯수 만큼 이벤트를 요청하면 다음과 같이 처음 의도한 대로 동작하는 것을 알 수 있다.

```terminal
[Subscriber] onSubscribe
[Subscriber] onNext : 1
[Subscriber] onNext : 2
[Subscriber] onNext : 3
[Subscriber] onComplete
```

일반적으로 사용되는 Subscriber의 경우 long 형의 최댓값으로 이벤트를 요청하여 갯수에 상관없이 이벤트가 발생할 때마다 onNext 이벤트를 발생시키도록 요구한다.

실제로 Flux와 모노의 기본 Subscriber로 사용되는 LambdaSubscriber의 경우 onSubscribe() 에서 Subscription.request(Long.MAX_VALUE) 코드 라인을 통해 계속적인 이벤트를  Publisher에게 요청한다. 

```java
    ...
	@Override
    public void onSubscribe(Subscription subscription) {
        System.out.println("[Subscriber] onSubscribe");
        subscription.request(Long.MAX_VALUE); // 이벤트 요청
    }
	...
```

위와 같이 코드를 수정하더라도 위와 동일한 경과를 얻을 수 있다.

### 이벤트 수보다 적은 Subscription 요청

그렇다면 Publisher가 갖고있는 이벤트보다 적은 수의 이벤트를 요청하면 어떻게 동작하게 될까?

```java
	...
    @Override
    public void onSubscribe(Subscription subscription) {
        System.out.println("[Subscriber] onSubscribe");
        subscription.request(1); // 요청 갯수 변경
    }
    ...
```

 위의 코드는 하나의 이벤트만을 요청했고 Publisher로 부터 하나의 이벤트를 전달 받는다. 하지만 결과를 보면 onComplete 이벤트가 발생하지 않는 것을 알 수 있다.

```terminal
[Subscriber] onSubscribe
[Subscriber] onNext : 1
```

 Subscription의 request() 메서드는 Publisher에게 이벤트를 요청하는 pull 모델로 동작하지만, 그 요청한 갯수 만큼의 이벤트를 발생시키는 동안 Publisher는 push 모델로 동작한다. 때문에 Publisher의 이벤트가 남아있기 때문에 onComplete 이벤트를 발생시키지 않는 것이다.

## 에러처리

onNext 이벤트를 통해  Publisher가 전달하는 데이터를 처리하는 것 처럼 onError 이벤트를 통해 Publisher에서 발생한 Exception을 처리할 수 있다.

```java
Flux.just(1, 2, 3)
    .map(it -> {
        if (it == 3) throw new RuntimeException("Exception");
        return it;
    })
    .subscribe(
            item -> System.out.println("[Subscriber] onNext : " + item),
            e -> System.out.println("[Subscriber] onError : " + e.getMessage()),
            () -> System.out.println("[Subscriber] onComplete")
    );
```

위의 코드에선 Subscriber를 Consumer를 통해서 구현하였다. Flux의 기본 Subscriber는 long 형의 최댓값을 이용해 이벤트를 요청하므로 Publisher가 갖는 모든 이벤트를 요청받는다. 실행하면 다음과 같은 결과를 얻을 수 있다.

```
[Subscriber] onNext : 1
[Subscriber] onNext : 2
[Subscriber] onError : Exception
```

Subscriber에서 onError 이벤트를 통해 에러를 처리할 수 있지만, Publisher에서도 에러가 발생했을 때 이를 처리할 수 있다.

### onErrorReturn

```java
Flux.just(1, 2, 3)
    .map(it -> {
        if (it == 3) throw new RuntimeException("Exception");
        return it;
    })
    .onErrorReturn(-1)
    .subscribe(
            item -> System.out.println("[Subscriber] onNext : " + item),
            e -> System.out.println("[Subscriber] onError : " + e.getMessage()),
            () -> System.out.println("[Subscriber] onComplete")
    );
```

```
[Subscriber] onNext : 1
[Subscriber] onNext : 2
[Subscriber] onNext : -1
[Subscriber] onComplete
```

### onErrorStop

### onErrorContinue

```java
Flux.just(1, 2, 3)
    .map(it -> {
        if (it == 3) throw new RuntimeException("Exception");
        return it;
    })
    .onErrorContinue((e, item) -> System.out.println("[Publisher] onError : " + e.getMessage() + ", Cause by : " + item))
    .subscribe(
            item -> System.out.println("[Subscriber] onNext : " + item),
            e -> System.out.println("[Subscriber] onError : " + e.getMessage()),
            () -> System.out.println("[Subscriber] onComplete")
    );
```

```terminal
[Subscriber] onNext : 1
[Subscriber] onNext : 2
[Publisher] onError : Exception, Cause by : 3
[Subscriber] onComplete
```

### onErrorMap

```java
Flux.just(1, 2, 3)
    .map(it -> {
        if (it == 3) throw new RuntimeException("Exception");
        return it;
    })
    .onErrorMap(e -> new RuntimeException("New Exception"))
    .subscribe(
            item -> System.out.println("[Subscriber] onNext : " + item),
            e -> System.out.println("[Subscriber] onError : " + e.getMessage()),
            () -> System.out.println("[Subscriber] onComplete")
    );
```

```terminal
[Subscriber] onNext : 1
[Subscriber] onNext : 2
[Subscriber] onError : New Exception
```

### doOnError

```java
Flux.just(1, 2, 3)
    .map(it -> {
        if (it == 3) throw new RuntimeException("Exception");
        return it;
    })
    .doOnError((e) -> System.out.println("[Publisher] onError : " + e.getMessage()))
    .subscribe(
            item -> System.out.println("[Subscriber] onNext : " + item),
            e -> System.out.println("[Subscriber] onError : " + e.getMessage()),
            () -> System.out.println("[Subscriber] onComplete")
    );
```

```terminal
[Subscriber] onNext : 1
[Subscriber] onNext : 2
[Publisher] onError : Exception
[Subscriber] onError : Exception
```

### retry

```java
Flux.just(1, 2, 3)
    .map(it -> {
        if (it == 3) throw new RuntimeException("Exception");
        return it;
    })
    .retry(1)
    .subscribe(
            item -> System.out.println("[Subscriber] onNext : " + item),
            e -> System.out.println("[Subscriber] onError : " + e.getMessage()),
            () -> System.out.println("[Subscriber] onComplete")
    );
```

```terminal
[Subscriber] onNext : 1
[Subscriber] onNext : 2
[Subscriber] onNext : 1 // 한번 재시도
[Subscriber] onNext : 2
[Subscriber] onError : Exception
```

### retryWhen

// 넘 어렵

## Mono와 Flux

// Mono가 필요한 이유

### 시퀸스 생성

just

from

// Flux

range

fromIterable

fromArray

fromStream

// mono

fromCallable

fromCompletionStage

fromDirect

fromFuture

fromRunnable

fromSupplier

### 시퀸스 변환 / 병합

filter

map

flatMap

// Flux

collect

collectMap

collectList

// Mono

flatMapMany

flatMapIterable

## 리액티브 스케줄러 종류

리액터는 다음 스케줄러를 기본 제공한다.

- Schedulers.immediate() : 현재 쓰레드에서 실행한다.
- Schedulers.single() : 쓰레드가 한 개인 쓰레드 풀을 이용해서 실행한다. 즉 한 쓰레드를 공유한다.
- Schedulers.elastic() : 쓰레드 풀을 이용해서 실행한다. 블로킹 IO를 리액터로 처리할 때 적합하다. 쓰레드가 필요하면 새로 생성하고 일정 시간(기본 60초) 이상 유휴 상태인 쓰레드는 제거한다. 데몬 쓰레드를 생성한다.
- Schedulers.parallel() : 고정 크기 쓰레드 풀을 이용해서 실행한다. 병렬 작업에 적합하다.



https://projectreactor.io/docs/core/release/reference/