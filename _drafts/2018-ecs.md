---
title: ECS
date: 2018-04-18
categories:
- Game
tags:
- Development
- Game
---

  ECS는 Entity, Component, System의 약자로, 이 세가지의 요소로 설계하는 아키텍쳐 패턴이다. 몇몇 상용 엔진에서 잘 사용하고 있는 컴포넌트 모델<sup>Component Model</sup>과도 다르고, 90년대 후반과 2000년대 초반에 주로 쓰였던 고전적인 액터 모델<sup>Actor Model</sup>과도 확연히 다르다. 컴포넌트 모델이나 액터 모델의 경우 상태<sup>State</sup>와 로직<sup>Behavior</sup>을 동시에 갖고 있지만 ECS는 상태와 로직를 컴포넌트와 시스템, 이 두개의 요소를 통해 분리했기 때문이다.

 ECS는 다음과 같이 구성된다

![ecs-0](https://user-images.githubusercontent.com/18159012/38994825-6b792514-4422-11e8-9002-704e68d5ecf1.png)

 월드는 시스템과 엔티티의 집합체로 구성된다. 엔티티는 컴포넌트의 집합체에 해당하며 유니크한 아이디를 갖는다. 컴포넌트는 상태를 저장하고 로직이 없는 반면, 시스템은 로직은 있지만, 상태를 저장하지 않는다. 쉽게말해 컴포넌트는 Function이 없고, 시스템은 Field가 없다.

 때문에 여러 오브젝트들이 상호작용을 하는 월드(게임) 안에서 뷰와 로직과 데이터를 분리하여 관리할 수 있다. 때문에 OOP만으로 불가능한 복잡한 기능 조합의 설계가 가능하다. 예를 들어 다음과 같은 오브젝트를 구현한다고 해보자.

|          |  조작  |  타기  |  공격  |  날기  |
| :------: | :----: | :----: | :----: | :----: |
| 플레이어 |  가능  | 불가능 |  가능  | 불가능 |
|    말    | 불가능 |  가능  | 불가능 | 불가능 |
|  고블린  | 불가능 | 불가능 |  가능  | 불가능 |
|  드래곤  | 불가능 |  가능  |  가능  |  가능  |

 어떤 식으로 구현을 해야할까? 모든 기능별로 메소드를 만들고 상속을 한다면 중복되는 구현이 너무 많다. 기능이 확장되는 방향으로 상속을 한다면 드래곤이 말을 상속 받고 플레이어가 고블린을 상속해야한다. 뭔가 이상하다.

 하지만 ESC를 사용한다면 각 행동에 필요한 컴포넌트만 추가해준다면 시스템에서 알아서 처리해준다. 새로운 시스템과 컴포넌트를 추가하는 게 아니라면 기존 컴포넌트들의 조합을 통해 새로운 오브젝트 또한 만들 수 있다. 

 또한 컴포넌트 모델에서 추상화를 통한 컴포넌트 간 통신을 위한 인터페이스가 기능에 따라 변경되는 문제도 해결할 수 있다.

...

# ESC의 동작

 컴포넌트나 엔티티의 경우 로직가 없기 때문에, 게임에서 어떤 로직이 실행되기 위해선 시스템의 로직을 사용해야한다. 때문에 게임의 한 프레임 또는 타임 틱<sup>Time Tick</sup> 마다 월드에 존재하는 시스템을 순회<sup>Iterate</sup>하며 로직을 실행한다. 여기서 시스템은 각 엔티티가 무엇인지 알 수 없다. 단지 일부 컴포넌트에 관여하고, 그 일부 컴포넌트에 대해 같은 로직을 수행한다.

 시스템의 로직을 수행하는데 하나 이상의 컴포넌트를 필요할 수 있다. 이 경우 컴포넌트는 한 엔티티에 같이 포함되는 컴포넌트에 접근할 수 있어야한다. 로직은 엔티티가 무엇인지 모르지만 컴포넌트가 저장하는 정보는 한 엔티티에 대한 정보이기 때문이다. 하지만 여러개의 컴포넌트를 필요로 하는 시스템 로직을 수행할 때 마다 엔티티가 포함하는 컴포넌트 리스트를 순회하는 것은 효율적이지 못하다. 

 



ECS를 이용하여 프로토타이핑 해보고, ECS로 변경한 것은 극단적인 선택은 아니었습니다. 우리는 3년이라는 개발 기간동안 ECS가 빠르게 변화하는 코드베이스(Code Base)에서 복잡성(Complexity)을 효과적으로 관리할 수 있다는 것을 발견하게 되었습니다.

ECS는 많은 장점을 가지고 있습니다.
