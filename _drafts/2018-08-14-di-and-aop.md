---
title: DI와 AOP
date: 2018-08-14
categories:
- Spring
tags:
- Development
- Spring
- Java
---

# DI<sup>Dependency Injection</sup>

객체 간의 의존관계를 객체 자신이 아닌 **외부로 부터 주입받아 객체 간의 결합도를 낮추는 것**을 말한다.

- 클래스간의 결합도를 낮춤
- **낮은 의존성을 통해 유닛테스트 도움**

## DI의 종류

1. 생성자 주입
2. 세터(Setter) 주입

## 스프링의 DI

객체가 의존관계를 갖기 위해선 생성자에서 다른 객체를 생성하는, 다른 객체를 담는 큰 객체로 부터 작은 객체를 생성하는 과정을 갖는다. 하지만 DI를 통해 생성되는 객체는 작은 객체를 주입 받기 위해 작은 객체를 먼저 생성하고 큰 객체가 이를 주입 받는, **제어의 역전:IoC<sup>Inverse of Control</sup>**이 발생한다.

스프링의 IoC 컨테이너는 이러한 의존성을 주입하는 역할을 위해 관리되는 오브젝트들을 bean으로 등록하여 관리한다. 이렇게 관리되는 bean들은 설정파일에 기술하여 컨테이너에게 관리될 오브젝트들을 알려주게 된다.

# AOP<sup>Aspect-Oriented Programming</sup>

DI가 애플리케이션 모듈들 간의 결합도를 낮춰준다면, AOP는 **애플리케이션 전체에 걸쳐 사용되는 기능을 재사용**하도록 지원하는 것입니다 

공통의 관심사항을 적용해서 발생하는 의존관계의 복잡성과 코드 중복을 해소해 주는 프로그래밍 기법

- 로그, 트랜잭션, 보안, 캐싱과 같은 부가적인 처리와 이런 기능들에 영향을 받는 객체간의 결합도를 낮춤
- 흩어져서 구현되는 **관심 기능을 하나의 장소로 응집**
- 코드의 재사용성이 높아져 가독성이 높아짐

[그림]

인터넷에 AOP에 대해 나와있는 내용 중 상당수가 설명이 부족한 경우가 있습니다.

특히 Controller에 AOP가 적용이 안된다거나 (사실 보통 Controller에는 AOP를 적용하지 않습니다. Interceptor가 있기 때문이죠. 그렇지만 어쩔수없이 Controller에도 AOP를 적용해야 할 수도 있기 때문에 여기서는 같이 설명을 하겠습니다.) 스프링의 다른 기능과 충돌이 나는 경우가 있습니다.

출처: http://addio3305.tistory.com/86

## 주요개념

1) 관점(Aspect)

구현하고자 하는 횡단 관심사의 기능을 의미한다. 한개 이상의 포인트컷과 어드바이스의 조합으로 만들어진다.

2) 조인포인트(Join point)

관점(Aspect)를 삽입하여 어드바이스가 적용될 수 있는 위치를 말한다. 

3) 어드바이스(Advice)

관점(Aspect)의 구현체로 조인 포인트에 삽입되어 동작하는 코드이다. 

어드바이스는 조인포인트와 결합하여 동작하는 시점에 따라 5개로 구분된다.

- Before Advice : 조인포인트 전에 실행되는 advice
- After returning advice : 조인포인트에서 성공적으로 리턴 된 후 실행되는 advice
- After throwing advice : 예외가 발생하였을 경우 실행되는 advice
- After advice : 조인포인트에서 메서드의 실행결과에 상관없이 무조건 실행되는 advice, 자바의 finally와 비슷한 역할을 한다.
- Around advice : 조인포인트의 전 과정(전, 후)에 수행되는 advice

4) 포인트컷(PointCut)

어드바이스를 적용할 조인 포인트를 선별하는 과정이나 그 기능을 정의한 모듈을 의미한다. 패턴매칭을 이용하여 어떤 조인포인트를 사용할 것인지 결정한다.

5) 타겟(Target)

어드바이스를 받을 대상, 즉 객체를 의미한다. 비지니스로직을 수행하는 클래스일수도 있지만, 프록시 객체(Object)가 될 수도 있다.

이 외에도 위빙(Weaving), 프록시(Proxy) 등의 여러가지 용어가 있지만, 지금 단계에서는 모두 알 필요는 없다. 

출처: http://addio3305.tistory.com/86

## AOP의 적용

이제 마지막으로 설명할 부분은 왜 action-servlet.xml과 context-aspect.xml 두 곳에서 AOP를 설정했는지에 대한 것이다. 

이는 Application Context의 계층구조와 연관이 되어 있다. 

지금 우리의 프로젝트는 2개의 컨텍스트가 설정이 되어있다. 

하나는 action-servlet.xml이고 다른 하나는 context-*.xml 파일이 그것인데, 이는 각각 Root Application Context, Servlet Context의 설정파일이다.

두개의 차이점은 다음과 같다.

### Root Application Context

\- 최상단 컨텍스트 

\- 서로 다른 서블릿 컨텍스트에서 공유하는 bean을 등록 

\- 웹에서 사용되는 컨트롤러 등을 등록

\- 서블릿 컨텍스트에서 등록된 bean을 사용할 수 없으며, 서블릿 컨텍스트와 루트 컨텍스트에서 동일한 bean을 설정할 경우, 서블릿 컨텍스트에서 설정한 bean만 동작

### Servlet Context

\- 서블릿에서 이용되는 컨텍스트

\- 여기서 정의된 bean은 다른 서블릿 컨텍스트와 공유할 수 없음

따라서 Controller와 관련된 bean은 action-servlet.xml에 설정하고, Service, DAO, Component등은 context-*에 설정하게 된다.

SpringMVC 개발에서는 이렇게 설정하는것이 원칙이다. 

우리가 설정한 AOP를 보면 Controller, Service, DAO의 3개 영역에서 모두 사용이 되어야 하는데, 한쪽의 컨텍스트에서만 설정하게 되면 다른 컨텍스트에서는 동작하지 않게 된다. 

예를 들어 action-servlet.xml에만 설정을 하면 Controller의 로그만 출력될 것이고, context-aspect.xml에서만 설정하면 Service, DAO에서만 로그가 출력이 될 것이다.

사실 이 글 전에 action-servlet.xml에서만 Component-scan을 했었는데, 이는 잘못된 방법이다. 

그렇지만 이번에 AOP를 설정하면서 같이 이야기를 하기 위해서 놔뒀었다. 

이번글에서 두가지 컨텍스트에 대해서 이야기를 하면서 왜 잘못되었고, 어떻게 해야하는지도 같이 살펴보게 되었다.

출처: http://addio3305.tistory.com/86